---
layout: post
title: Mysql锁、事务隔离级别、MVCC底层原理机制
category: Java
tags: [Java]
copyright: Java

---

## 锁定义

​		锁是计算机协调多个进程或线程并发访问某一资源的机制。
​		在数据库中，除了传统的计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供需要用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。

## 锁分类

1、从性能上分类：乐观锁和悲观锁

- 乐观锁： version字段（比较跟上一次的版本号，如果一样则更新，如果失败则要重复读-比较-写的操作。）
- 悲观锁：for update（锁定查询的行）

2、从对数据库操作的类型分，分为 读锁和写锁(都属于悲观锁)

- 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响
- 写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁

3、从对数据操作的粒度分，分为 表锁和行锁



其中扩展`表锁`和`行锁`

#### 表锁

每次操作锁住整张表。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲
突的概率最高，并发度最低。

手动增加表锁
`lock table 表名称 read(write),表名称2 read(write);`
查看表上加过的锁
`show open tables;`
删除表锁
`unlock tables;`

加读锁：当前session和其他session都可以读该表，当前session中插入或者更新锁定的表都会报错，其他session插入或更新则会等待。

加写锁：当前session对该表的增删改查都没有问题，其他session对该表的所有操作被阻塞。



MyISAM在执行查询语句(SELECT)前,会自动给涉及的所有表加读锁,在执行增删改操作前,会自动给涉及的表加写锁。
1、对MyISAM表的读操作(加读锁) ,不会阻寒其他进程对同一表的读请求,但会阻赛对同一表的写请求。只有当读锁释放后,才会执行其它进程的写操作。
2、对MylSAM表的写操作(加写锁) ,会阻塞其他进程对同一表的读和写操作,只有当写锁释放后,才会执行其它进程的读写操作
总结：
简而言之，就是读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞。

#### 行琐

每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。

InnoDB与MYISAM的最大不同有两点：

- 支持事务（TRANSACTION）
- 支持行级锁

支持事务（TRANSACTION）
支持行级锁

## 事务隔离级别

#### 事务（Transaction）及其ACID属性

行锁支持事务

事务是由一组SQL语句组成的逻辑处理单元,事务具有以下4个属性,通常简称为事务的ACID属性。

- 原子性(Atomicity) ：事务是一个原子操作单元,其对数据的修改,要么全都执行,要么全都不执行。
- 一致性(Consistent) ：在事务开始和完成时,数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改,以保持数据的完整性;事务结束时,所有的内部数据结构(如B树索引或双向链表)也都必须是正确的。
- 隔离性(Isolation) ：数据库系统提供一定的隔离机制,保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的,反之亦然。
- 持久性(Durable) ：事务完成之后,它对于数据的修改是永久性的,即使出现系统故障也能够保持。

#### 并发事务处理带来的问题

- 更新丢失（Lost Update）
  　　当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每
  个事务都不知道其他事务的存在，就会发生丢失更新问题–最后的更新覆盖了由其
  他事务所做的更新。
- 脏读（Dirty Reads）
  　　一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致的状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此作进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象的叫做“脏读”。
  　　一句话：事务A读取到了事务B已经修改但尚未提交的数据，还在这个数据基础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。
- 不可重读（Non-Repeatable Reads）
  　　一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。
  　　一句话：事务A读取到了事务B已经提交的修改数据，不符合隔离性
- 幻读（Phantom Reads）
  　　一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。
  　　一句话：事务A读取到了事务B提交的新增数据，不符合隔离性

#### 事务隔离级别

脏读”、“不可重复读”和“幻读”,其实都是数据库读一致性问题,必须由数
据库提供一定的事务隔离机制来解决。

![1578801689788](https://images.niaobulashi.com/typecho/uploads/2020/01/2642382755.png)

数据库的事务隔离越严格,并发副作用越小,但付出的代价也就越大,因为事务隔离实质上就是使事务在一定程度上“串行化”进行,这显然与“并发”是矛盾的。

同时,不同的应用对读一致性和事务隔离程度的要求也是不同的,比如许多应用对“不可重复读"和“幻读”并不敏感,可能更关心数据并发访问的能力。

常看当前数据库的事务隔离级别: show variables like 'tx_isolation';
设置事务隔离级别：set tx_isolation='REPEATABLE-READ';

简单描述一下隔离级别：

1、读未提交（Read uncommitted）

客户端A开启一个事务，查询用户表id=1的余额为400

在客户端A的事务提交之前，客户端B开启了另外一个事务，更新用户表id=1的余额为350，还未提交。此时客户A就可以查询到B已经更新的数据。如果客户端B回滚了，客户端B所有的操作被撤销，那么现在客户端A查询到的数据其实就是脏数据。

2、读已提交（Read committed）

客户端A开启一个事务，查询用户表id=1的余额为400

在客户端A的事务提交之前，客户端B开启一个事务，更新用户表id=1的余额为350，还未提交。此时客户端A不能查询B已经更新的数据，解决了脏数据的问题。

此时客户端B提交，客户A再进行查询，结果和上述不一致了，查询结果是客户端B更新后的数据350，即产生了不可重复读的问题。

3、可重复度（Repeatable read）

客户端A开启一个事务，查询用户表id=1的余额为400

在客户端A的事务提交之前，客户端B开启一个事务，更新用户表id=1的余额为350，提交。此时客户端A再查询用户id=1的余额还是和上一次一样是400，解决了不可重复度的问题。

此时客户端A执行更新余额，将余额-50，预测应该更新为350，但是却是300。余额使用的是客户端B提交的数据，最后数据的一致性倒是没有被破快。那么这是什么原理呢？

这是因为Mysql在可重复度隔离级别下使用了MVCC（multi-version concurrency control）机制。

select操作不会更新版本号，快照读（历史版本）（readview，快照）；

insert、update和delete会更新版本号，当前读（当前版本）。

重新打开客户端B，插入一条新的数据id=4

在客户端A查询用户表，没有查询出新的数据

客户端A执行更新语句条件是where id = 4，查询更新成功。再次查询就可以查询到客户端B新增的用户id=4的数据，出现幻读。

## MVCC机制

如果事务隔离级别是可重复读，那快照readview是第一次查询时所生产的。

每一个事务开启到提交中间，每次insert、update、delete操作都会生成一个undo回滚日志。



![1578803927800](https://images.niaobulashi.com/typecho/uploads/2020/01/2715093167.png)

这里模拟不同的客户端操作，操作顺序从上到下。

![1578804320776](https://images.niaobulashi.com/typecho/uploads/2020/01/2475687894.png)






